### 第一次见到javap指令

那么今天我学会了一个特别诡异的命令今天我来试试看，javac ，或许你会说，诶，这个我刚学会的时候我就会了诶，怎么讲，不就是把java文件生成了一个class结尾的文件吗？这个不简单的很。打开了这个class文件后就会发现，里面都是一些看不懂的天书内容。但是没有关系，我还发现了一个命令叫javap，诶，这个是反编译，它可以把这个class文件反编译后，诶，你就能看的懂了，甚至还可以知道他是怎么执行的。那我们就来试一下。写一个简单的hello world。



```java
public class HelloWorld {
    public static void main(String[] args) {
        String helloWorld = "hello world";
        System.out.println(helloWorld);
    }
}
```

那么接下来就可以反编译了

```bash
javac HelloWorld.java
```

他生成了一个class文件

我直接用vim打开看看

```bash
vim HelloWorld.class
```

甚至完全看不懂。

```java
Êþº¾^@^@^@4^@^]
^@^F^@^O^H^@^P  ^@^Q^@^R
^@^S^@^T^G^@^U^G^@^V^A^@^F<init>^A^@^C()V^A^@^DCode^A^@^OLineNumberTable^A^@^Dmain^A^@^V([Ljava/lang/String;)V^A^@
SourceFile^A^@^OHelloWorld.java^L^@^G^@^H^A^@^Khello world^G^@^W^L^@^X^@^Y^G^@^Z^L^@^[^@^\^A^@"com/nanjolono/test/test/HelloWorld^A^@^Pjava/lang/Object^A^@^Pjava/lang/System^A^@^Cout^A^@^ULjava/io/PrintStream;^A^@^Sjava/io/PrintStream^A^@^Gprintln^A^@^U(Ljava/lang/String;)V^@!^@^E^@^F^@^@^@^@^@^B^@^A^@^G^@^H^@^A^@     ^@^@^@^]^@^A^@^A^@^@^@^E*·^@^A±^@^@^@^A^@
^@^@^@^F^@^A^@^@^@^E^@  ^@^K^@^L^@^A^@  ^@^@^@+^@^B^@^B^@^@^@^K^R^BL²^@^C+¶^@^D±^@^@^@^A^@
^@^@^@^N^@^C^@^@^@^G^@^C^@^H^@
^@      ^@^A^@^M^@^@^@^B^@^N
~                               
```

但是没有关系，我们来使用javap反编译一下

```bash
javap -c HelloWorld.class
```

```bash
Compiled from "HelloWorld.java"
public class com.nanjolono.test.test.HelloWorld {
  public com.nanjolono.test.test.HelloWorld();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String hello world
       2: astore_1
       3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       6: aload_1
       7: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      10: return
}
```

这好像是人类能看的懂的东西了，那么他分了几个步骤，甚至执行顺序，

那么不难推测

这个使用了ldc将字符串压入栈中，

astore指令存储将我们声明的字符串存储到1区域

然后调用静态方法getstatic

aload加载1区域的内容，也就是我们的字符串

通过了invokevirtual指令来调用java.io.PrintStream.println:(Ljava/lang/String;)方法。

那么简单的hello world就有这么多的方法了。

